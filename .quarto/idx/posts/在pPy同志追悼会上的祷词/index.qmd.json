{"title":"在 pPy 同志追悼会上的祷词","markdown":{"yaml":{"title":"在 pPy 同志追悼会上的祷词","author":"Midstream","date":"2022-09-05","categories":["日常","学习笔记"],"description":"临时兴起很容易，做下去很难。"},"headingText":"include \"Python.h\"","containsRefs":false,"markdown":"\n\n我发现，在C的层面上实现pPy几乎是不可能了。\n\npPy，即polite-Python，这颗曾乘风飞翔了两天的蒲公英种子落在了一块名为C的板结的固土上，十个小时后死去了。与它一同被沙土埋葬的，还有它在云端舞蹈时绮丽的幻想，和它窥探到的来自天堂的能使人间和睦的福音。\n\n\n自落地后，pPy的挣扎从LL(1) parser开始。\n\n当摸着石头淌进编译原理的深潭时，我发现，python在3.9版本的[PEP617](https://peps.python.org/pep-0617/#background-on-ll-1-parsers)中弃用了LL(1) parser，作为一个相对较新的版本，偌大的互联网竟没有几篇资料。新版的python改用了PEG parser，致使cpython源码中的Grammar文件也被弃用，连带更新了大量的编译器源码，仅有的几篇技术博客也早已过时。\n\n新版的python语法规则放在`Grammar/Python.gram`文件中，相应的token则放在`Grammar/Tokens`里。Python运行时，python的语法会首先经过`Parser/tokenizer.c`这个文件，被按照token文件的规则解构成一个个token，而后被送入`Parser/parser.c`中进行翻译。parser会依据`Parser/Python.asdl`这个文件中的语法将token们解析成AST然后继而变成可以被执行的code object。因此，在实际操作中，当尝试更改语法时，`Python/Python-ast.c`, `Python/ast.c`， 以及`Python/symtable.c`中的代码也需要更改。好在，这些文件里的部分是可以自动生成的，但是依然有相当一部分需要手动更改。\n\n最关键的`parser.c`是不用改的，因为这个编译器是被pegen模块生成的，pegen有两个版本，一个是c的老版本，一个是python的新版本，在`Tools/peg_generator/pegen`里。确实，python甚至可以在自己还没有被编译好的时候运行自己的python代码，好像是预先编译过了。在我编译cpython时，老版本的`Parser/pegen.c`似乎没有被弃用，依然运行，执行的工作却和生成文件关系不大。有意思的是，pegen这个编译编译器的编译器甚至也是被一个编译器编译的，因为pegen是翻译`Grammar/Python.gram`的，而这个语法的语法规则被是被元语法定义的。元语法在这里`Tools/peg_generator/pegen/metagrammar.gram`, 不过这个应该很少会需要改动。\n\n在cpython里，函数的调用关系和上述流程并不相同。如`Parser/tokenizer.c`中的第1352到2064行有一个相当长的函数叫`tok_get`，里面是具体python如何处理文本字符串的。这个函数最终会被`Parser/pegen.c`里的`_PyPegen_fill_token`函数调用，而这个函数则在生成的`Parser/parser.c`中被大量调用。这么说来终究是有些模糊，那就从python运行的主函数开始吧。\n\n```c\n/* Minimal main program -- everything is loaded from the library */\n\n\n#ifdef MS_WINDOWS\nint\nwmain(int argc, wchar_t **argv)\n{\n    return Py_Main(argc, argv);\n}\n#else\nint\nmain(int argc, char **argv)\n{\n    return Py_BytesMain(argc, argv);\n}\n#endif\n\n// 这里就是整个python的主函数所在了，一切的python的入口都在这里。\n// 这个函数只是简单区分了一下windows和别的操作系统，我们进到main函数里面看一下。\n\nint\nPy_BytesMain(int argc, char **argv)\n{\n    _PyArgv args = {\n        .argc = argc,\n        .use_bytes_argv = 1,\n        .bytes_argv = argv,\n        .wchar_argv = NULL};\n    return pymain_main(&args);\n}\n\n#ifdef __cplusplus\n\n\n// 注意，从这里开始，文件就不再在Programs/main.c了，而是在Modules/main.c里面\n// 没做什么事儿，接着往下走\n\n\nstatic int\npymain_main(_PyArgv *args)\n{\n    PyStatus status = pymain_init(args);\n    if (_PyStatus_IS_EXIT(status)) {\n        pymain_free();\n        return status.exitcode;\n    }\n    if (_PyStatus_EXCEPTION(status)) {\n        pymain_exit_error(status);\n    }\n\n    return Py_RunMain();\n}\n\n// 这个pymain_init函数是一个非常关键的函数，里面包含了所有python启动之前的初始化\n// 里面结构非常复杂，并且牵涉到很多GIL的操作，介于我们的pPy并不需要关注这些内容，\n// 在这里就进入Py_RunMain，不去关注初始化，直接开始运行\n\n\nint\nPy_RunMain(void)\n{\n    int exitcode = 0;\n\n    pymain_run_python(&exitcode);\n\n    if (Py_FinalizeEx() < 0) {\n        /* Value unlikely to be confused with a non-error exit status or\n           other special meaning */\n        exitcode = 120;\n    }\n\n    pymain_free();\n\n    if (_Py_UnhandledKeyboardInterrupt) {\n        exitcode = exit_sigint();\n    }\n\n    return exitcode;\n}\n\n// 状态码，不重要\n\n\nstatic void\npymain_run_python(int *exitcode)\n{\n    PyObject *main_importer_path = NULL;\n    PyInterpreterState *interp = _PyInterpreterState_GET();\n    /* pymain_run_stdin() modify the config */\n    PyConfig *config = (PyConfig*)_PyInterpreterState_GetConfig(interp);\n\n    /* ensure path config is written into global variables */\n    if (_PyStatus_EXCEPTION(_PyPathConfig_UpdateGlobal(config))) {\n        goto error;\n    }\n\n    if (config->run_filename != NULL) {\n        /* If filename is a package (ex: directory or ZIP file) which contains\n           __main__.py, main_importer_path is set to filename and will be\n           prepended to sys.path.\n\n           Otherwise, main_importer_path is left unchanged. */\n        if (pymain_get_importer(config->run_filename, &main_importer_path,\n                                exitcode)) {\n            return;\n        }\n    }\n\n    // import readline and rlcompleter before script dir is added to sys.path\n    pymain_import_readline(config);\n\n    if (main_importer_path != NULL) {\n        if (pymain_sys_path_add_path0(interp, main_importer_path) < 0) {\n            goto error;\n        }\n    }\n    else if (!config->safe_path) {\n        PyObject *path0 = NULL;\n        int res = _PyPathConfig_ComputeSysPath0(&config->argv, &path0);\n        if (res < 0) {\n            goto error;\n        }\n\n        if (res > 0) {\n            if (pymain_sys_path_add_path0(interp, path0) < 0) {\n                Py_DECREF(path0);\n                goto error;\n            }\n            Py_DECREF(path0);\n        }\n    }\n\n    pymain_header(config);\n\n    if (config->run_command) {\n        *exitcode = pymain_run_command(config->run_command);\n    }\n    else if (config->run_module) {\n        *exitcode = pymain_run_module(config->run_module, 1);\n    }\n    else if (main_importer_path != NULL) {\n        *exitcode = pymain_run_module(L\"__main__\", 0);\n    }\n    else if (config->run_filename != NULL) {\n        *exitcode = pymain_run_file(config);\n    }\n    else {\n        *exitcode = pymain_run_stdin(config);\n    }\n\n    pymain_repl(config, exitcode);\n    goto done;\n\nerror:\n    *exitcode = pymain_exit_err_print();\n\ndone:\n    Py_XDECREF(main_importer_path);\n}\n\n// python可以通过各种不同的方式启动，在这个文件里做了规定，进到通过文件启动 pymain_run_file ，也就是我最常用的模式。\n\n\nstatic int\npymain_run_file(const PyConfig *config)\n{\n    PyObject *filename = PyUnicode_FromWideChar(config->run_filename, -1);\n    if (filename == NULL) {\n        PyErr_Print();\n        return -1;\n    }\n    PyObject *program_name = PyUnicode_FromWideChar(config->program_name, -1);\n    if (program_name == NULL) {\n        Py_DECREF(filename);\n        PyErr_Print();\n        return -1;\n    }\n\n    int res = pymain_run_file_obj(program_name, filename,\n                                  config->skip_source_first_line);\n    Py_DECREF(filename);\n    Py_DECREF(program_name);\n    return res;\n}\n\n// 读取文件名和文件信息，不重要\n// 进入pymain_run_file_obj\n\n\nstatic int\npymain_run_file_obj(PyObject *program_name, PyObject *filename,\n                    int skip_source_first_line)\n{\n    if (PySys_Audit(\"cpython.run_file\", \"O\", filename) < 0) {\n        return pymain_exit_err_print();\n    }\n\n    FILE *fp = _Py_fopen_obj(filename, \"rb\");\n    if (fp == NULL) {\n        // Ignore the OSError\n        PyErr_Clear();\n        PySys_FormatStderr(\"%S: can't open file %R: [Errno %d] %s\\n\",\n                           program_name, filename, errno, strerror(errno));\n        return 2;\n    }\n\n    if (skip_source_first_line) {\n        int ch;\n        /* Push back first newline so line numbers remain the same */\n        while ((ch = getc(fp)) != EOF) {\n            if (ch == '\\n') {\n                (void)ungetc(ch, fp);\n                break;\n            }\n        }\n    }\n\n    struct _Py_stat_struct sb;\n    if (_Py_fstat_noraise(fileno(fp), &sb) == 0 && S_ISDIR(sb.st_mode)) {\n        PySys_FormatStderr(\"%S: %R is a directory, cannot continue\\n\",\n                           program_name, filename);\n        fclose(fp);\n        return 1;\n    }\n\n    // Call pending calls like signal handlers (SIGINT)\n    if (Py_MakePendingCalls() == -1) {\n        fclose(fp);\n        return pymain_exit_err_print();\n    }\n\n    /* PyRun_AnyFileExFlags(closeit=1) calls fclose(fp) before running code */\n    PyCompilerFlags cf = _PyCompilerFlags_INIT;\n    int run = _PyRun_AnyFileObject(fp, filename, 1, &cf);\n    return (run != 0);\n}\n\n// 终于，在嵌套了这么多层之后，文件被打开了，存在 FILE *fp 里面。 无法打开文件的异常也是在这个函数里抛出的。\n// 直接进入到_PyRun_AnyFileObject\n\n\nint\n_PyRun_AnyFileObject(FILE *fp, PyObject *filename, int closeit,\n                     PyCompilerFlags *flags)\n{\n    int decref_filename = 0;\n    if (filename == NULL) {\n        filename = PyUnicode_FromString(\"???\");\n        if (filename == NULL) {\n            PyErr_Print();\n            return -1;\n        }\n        decref_filename = 1;\n    }\n\n    int res;\n    if (_Py_FdIsInteractive(fp, filename)) {\n        res = _PyRun_InteractiveLoopObject(fp, filename, flags);\n        if (closeit) {\n            fclose(fp);\n        }\n    }\n    else {\n        res = _PyRun_SimpleFileObject(fp, filename, closeit, flags);\n    }\n\n    if (decref_filename) {\n        Py_DECREF(filename);\n    }\n    return res;\n}\n\n// 在这里可以看到python的运行又出现了分支，分别是_PyRun_InteractiveLoopObject， _PyRun_SimpleFileObject\n// 从debug信息里推测前者应该是指python的命令行交互模式，后者指运行单个python文件。\n// 因为后者牵涉到很多文件的配置信息，比较麻烦，作为展示就直接进入到_PyRun_InteractiveLoopObject里面。\n\n\nint\n_PyRun_InteractiveLoopObject(FILE *fp, PyObject *filename, PyCompilerFlags *flags)\n{\n    PyCompilerFlags local_flags = _PyCompilerFlags_INIT;\n    if (flags == NULL) {\n        flags = &local_flags;\n    }\n\n    PyThreadState *tstate = _PyThreadState_GET();\n    PyObject *v = _PySys_GetAttr(tstate, &_Py_ID(ps1));\n    if (v == NULL) {\n        _PySys_SetAttr(&_Py_ID(ps1), v = PyUnicode_FromString(\">>> \"));\n        Py_XDECREF(v);\n    }\n    v = _PySys_GetAttr(tstate, &_Py_ID(ps2));\n    if (v == NULL) {\n        _PySys_SetAttr(&_Py_ID(ps2), v = PyUnicode_FromString(\"... \"));\n        Py_XDECREF(v);\n    }\n\n#ifdef Py_REF_DEBUG\n    int show_ref_count = _Py_GetConfig()->show_ref_count;\n#endif\n    int err = 0;\n    int ret;\n    int nomem_count = 0;\n    do {\n        ret = PyRun_InteractiveOneObjectEx(fp, filename, flags);\n        if (ret == -1 && PyErr_Occurred()) {\n            /* Prevent an endless loop after multiple consecutive MemoryErrors\n             * while still allowing an interactive command to fail with a\n             * MemoryError. */\n            if (PyErr_ExceptionMatches(PyExc_MemoryError)) {\n                if (++nomem_count > 16) {\n                    PyErr_Clear();\n                    err = -1;\n                    break;\n                }\n            } else {\n                nomem_count = 0;\n            }\n            PyErr_Print();\n            flush_io();\n        } else {\n            nomem_count = 0;\n        }\n#ifdef Py_REF_DEBUG\n        if (show_ref_count) {\n            _PyDebug_PrintTotalRefs();\n        }\n#endif\n    } while (ret != E_EOF);\n    return err;\n}\n\n// 可以看到，在这个函数里已经开始打印python交互模式的'>>>'了\n// 这个函数里我们需要关注的是PyRun_InteractiveOneObjectEx，也就是具体python的每一句话都是怎么被执行的\n\n\n/* A PyRun_InteractiveOneObject() auxiliary function that does not print the\n * error on failure. */\nstatic int\nPyRun_InteractiveOneObjectEx(FILE *fp, PyObject *filename,\n                             PyCompilerFlags *flags)\n{\n    PyObject *m, *d, *v, *w, *oenc = NULL;\n    mod_ty mod;\n    PyArena *arena;\n    const char *ps1 = \"\", *ps2 = \"\", *enc = NULL;\n    int errcode = 0;\n    PyThreadState *tstate = _PyThreadState_GET();\n\n    if (fp == stdin) {\n        /* Fetch encoding from sys.stdin if possible. */\n        v = _PySys_GetAttr(tstate, &_Py_ID(stdin));\n        if (v && v != Py_None) {\n            oenc = PyObject_GetAttr(v, &_Py_ID(encoding));\n            if (oenc)\n                enc = PyUnicode_AsUTF8(oenc);\n            if (!enc)\n                PyErr_Clear();\n        }\n    }\n    v = _PySys_GetAttr(tstate, &_Py_ID(ps1));\n    if (v != NULL) {\n        v = PyObject_Str(v);\n        if (v == NULL)\n            PyErr_Clear();\n        else if (PyUnicode_Check(v)) {\n            ps1 = PyUnicode_AsUTF8(v);\n            if (ps1 == NULL) {\n                PyErr_Clear();\n                ps1 = \"\";\n            }\n        }\n    }\n    w = _PySys_GetAttr(tstate, &_Py_ID(ps2));\n    if (w != NULL) {\n        w = PyObject_Str(w);\n        if (w == NULL)\n            PyErr_Clear();\n        else if (PyUnicode_Check(w)) {\n            ps2 = PyUnicode_AsUTF8(w);\n            if (ps2 == NULL) {\n                PyErr_Clear();\n                ps2 = \"\";\n            }\n        }\n    }\n    arena = _PyArena_New();\n    if (arena == NULL) {\n        Py_XDECREF(v);\n        Py_XDECREF(w);\n        Py_XDECREF(oenc);\n        return -1;\n    }\n\n    mod = _PyParser_ASTFromFile(fp, filename, enc, Py_single_input,\n                                ps1, ps2, flags, &errcode, arena);\n\n    Py_XDECREF(v);\n    Py_XDECREF(w);\n    Py_XDECREF(oenc);\n    if (mod == NULL) {\n        _PyArena_Free(arena);\n        if (errcode == E_EOF) {\n            PyErr_Clear();\n            return E_EOF;\n        }\n        return -1;\n    }\n    m = PyImport_AddModuleObject(&_Py_ID(__main__));\n    if (m == NULL) {\n        _PyArena_Free(arena);\n        return -1;\n    }\n    d = PyModule_GetDict(m);\n    v = run_mod(mod, filename, d, d, flags, arena);\n    _PyArena_Free(arena);\n    if (v == NULL) {\n        return -1;\n    }\n    Py_DECREF(v);\n    flush_io();\n    return 0;\n}\n\n// 前面的编码部分全部跳过不看，找到_PyParser_ASTFromFile这个函数\n// 从名字就可以看出，这个函数已经进入到编译器的部分了，用于从文件获得AST\n\nmod_ty\n_PyParser_ASTFromFile(FILE *fp, PyObject *filename_ob, const char *enc,\n                      int mode, const char *ps1, const char* ps2,\n                      PyCompilerFlags *flags, int *errcode, PyArena *arena)\n{\n    if (PySys_Audit(\"compile\", \"OO\", Py_None, filename_ob) < 0) {\n        return NULL;\n    }\n    return _PyPegen_run_parser_from_file_pointer(fp, mode, filename_ob, enc, ps1, ps2,\n                                        flags, errcode, arena);\n}\n\n// 进来以后发现是编译器的API文件，说明我们找的没错，接着往里走\n\n\nmod_ty\n_PyPegen_run_parser_from_file_pointer(FILE *fp, int start_rule, PyObject *filename_ob,\n                             const char *enc, const char *ps1, const char *ps2,\n                             PyCompilerFlags *flags, int *errcode, PyArena *arena)\n{\n    struct tok_state *tok = _PyTokenizer_FromFile(fp, enc, ps1, ps2);\n    if (tok == NULL) {\n        if (PyErr_Occurred()) {\n            _PyPegen_raise_tokenizer_init_error(filename_ob);\n            return NULL;\n        }\n        return NULL;\n    }\n    if (!tok->fp || ps1 != NULL || ps2 != NULL ||\n        PyUnicode_CompareWithASCIIString(filename_ob, \"<stdin>\") == 0) {\n        tok->fp_interactive = 1;\n    }\n    // This transfers the ownership to the tokenizer\n    tok->filename = filename_ob;\n    Py_INCREF(filename_ob);\n\n    // From here on we need to clean up even if there's an error\n    mod_ty result = NULL;\n\n    int parser_flags = compute_parser_flags(flags);\n    Parser *p = _PyPegen_Parser_New(tok, start_rule, parser_flags, PY_MINOR_VERSION,\n                                    errcode, arena);\n    if (p == NULL) {\n        goto error;\n    }\n\n    result = _PyPegen_run_parser(p);\n    _PyPegen_Parser_Free(p);\n\nerror:\n    _PyTokenizer_Free(tok);\n    return result;\n}\n\n// 到这一步，这个函数就已经存在于我们在文章一开始就提到的pegen.c之中了，\n// 已经即将进入到我们所熟悉的领域了（放屁，一点都不熟）\n\n// 这里略加说明，这个函数和上一个函数返回的 mod_ty 的定义如下\n// struct _mod {\n//     enum _mod_kind kind;\n//     union {\n//         struct {\n//             asdl_stmt_seq *body;\n//             asdl_type_ignore_seq *type_ignores;\n//         } Module;\n\n//         struct {\n//             asdl_stmt_seq *body;\n//         } Interactive;\n\n//         struct {\n//             expr_ty body;\n//         } Expression;\n\n//         struct {\n//             asdl_expr_seq *argtypes;\n//             expr_ty returns;\n//         } FunctionType;\n\n//     } v;\n// };\n\n// 这个结构体是构建AST用的，里面的asdl_stmt_seq等结构全部都来自一个_stmt的结构体，它的定义如下\n// 注意，这里你们会看到一个Thanks_kind,这个是原版python里面不存在的，是我为了测试pPy的时候增加的关键字，其作用和pass一样\n// 可以看到，再stmt里面定义了python所有内置的关键字\n\n// enum _stmt_kind {FunctionDef_kind=1, AsyncFunctionDef_kind=2, ClassDef_kind=3,\n//                   Return_kind=4, Delete_kind=5, Assign_kind=6,\n//                   AugAssign_kind=7, AnnAssign_kind=8, For_kind=9,\n//                   AsyncFor_kind=10, While_kind=11, If_kind=12, With_kind=13,\n//                   AsyncWith_kind=14, Match_kind=15, Raise_kind=16, Try_kind=17,\n//                   TryStar_kind=18, Assert_kind=19, Import_kind=20,\n//                   ImportFrom_kind=21, Global_kind=22, Nonlocal_kind=23,\n//                   Expr_kind=24, Pass_kind=25, Thanks_kind=26, Break_kind=27,\n//                   Continue_kind=28};\n// struct _stmt {\n//     enum _stmt_kind kind;\n//     union {\n//         struct {\n//             identifier name;\n//             arguments_ty args;\n//             asdl_stmt_seq *body;\n//             asdl_expr_seq *decorator_list;\n//             expr_ty returns;\n//             string type_comment;\n//         } FunctionDef;\n\n//         struct {\n//             identifier name;\n//             arguments_ty args;\n//             asdl_stmt_seq *body;\n//             asdl_expr_seq *decorator_list;\n//             expr_ty returns;\n//             string type_comment;\n//         } AsyncFunctionDef;\n\n//         struct {\n//             identifier name;\n//             asdl_expr_seq *bases;\n//             asdl_keyword_seq *keywords;\n//             asdl_stmt_seq *body;\n//             asdl_expr_seq *decorator_list;\n//         } ClassDef;\n\n//         struct {\n//             expr_ty value;\n//         } Return;\n\n//         struct {\n//             asdl_expr_seq *targets;\n//         } Delete;\n\n//         struct {\n//             asdl_expr_seq *targets;\n//             expr_ty value;\n//             string type_comment;\n//         } Assign;\n\n//         struct {\n//             expr_ty target;\n//             operator_ty op;\n//             expr_ty value;\n//         } AugAssign;\n\n//         struct {\n//             expr_ty target;\n//             expr_ty annotation;\n//             expr_ty value;\n//             int simple;\n//         } AnnAssign;\n\n//         struct {\n//             expr_ty target;\n//             expr_ty iter;\n//             asdl_stmt_seq *body;\n//             asdl_stmt_seq *orelse;\n//             string type_comment;\n//         } For;\n\n//         struct {\n//             expr_ty target;\n//             expr_ty iter;\n//             asdl_stmt_seq *body;\n//             asdl_stmt_seq *orelse;\n//             string type_comment;\n//         } AsyncFor;\n\n//         struct {\n//             expr_ty test;\n//             asdl_stmt_seq *body;\n//             asdl_stmt_seq *orelse;\n//         } While;\n\n//         struct {\n//             expr_ty test;\n//             asdl_stmt_seq *body;\n//             asdl_stmt_seq *orelse;\n//         } If;\n\n//         struct {\n//             asdl_withitem_seq *items;\n//             asdl_stmt_seq *body;\n//             string type_comment;\n//         } With;\n\n//         struct {\n//             asdl_withitem_seq *items;\n//             asdl_stmt_seq *body;\n//             string type_comment;\n//         } AsyncWith;\n\n//         struct {\n//             expr_ty subject;\n//             asdl_match_case_seq *cases;\n//         } Match;\n\n//         struct {\n//             expr_ty exc;\n//             expr_ty cause;\n//         } Raise;\n\n//         struct {\n//             asdl_stmt_seq *body;\n//             asdl_excepthandler_seq *handlers;\n//             asdl_stmt_seq *orelse;\n//             asdl_stmt_seq *finalbody;\n//         } Try;\n\n//         struct {\n//             asdl_stmt_seq *body;\n//             asdl_excepthandler_seq *handlers;\n//             asdl_stmt_seq *orelse;\n//             asdl_stmt_seq *finalbody;\n//         } TryStar;\n\n//         struct {\n//             expr_ty test;\n//             expr_ty msg;\n//         } Assert;\n\n//         struct {\n//             asdl_alias_seq *names;\n//         } Import;\n\n//         struct {\n//             identifier module;\n//             asdl_alias_seq *names;\n//             int level;\n//         } ImportFrom;\n\n//         struct {\n//             asdl_identifier_seq *names;\n//         } Global;\n\n//         struct {\n//             asdl_identifier_seq *names;\n//         } Nonlocal;\n\n//         struct {\n//             expr_ty value;\n//         } Expr;\n\n//     } v;\n//     int lineno;\n//     int col_offset;\n//     int end_lineno;\n//     int end_col_offset;\n// };\n\n\n// 回到刚才的函数，注意它的返回值 result = _PyPegen_run_parser(p);\n// 这说明就是这个 _PyPegen_run_parser 函数生成了已经被编译成 mod_ty 的python源码。\n// 传进去的参数p是一个parser结构体，API也在pegen.c这个文件里，涉及到内存管理，\n// 并且这个parser也拿了很多tokenize的函数进去，太复杂我直接跳过了。\n\nvoid *\n_PyPegen_run_parser(Parser *p)\n{\n    void *res = _PyPegen_parse(p);\n    assert(p->level == 0);\n    if (res == NULL) {\n        if ((p->flags & PyPARSE_ALLOW_INCOMPLETE_INPUT) &&  _is_end_of_source(p)) {\n            PyErr_Clear();\n            return RAISE_SYNTAX_ERROR(\"incomplete input\");\n        }\n        if (PyErr_Occurred() && !PyErr_ExceptionMatches(PyExc_SyntaxError)) {\n            return NULL;\n        }\n       // Make a second parser pass. In this pass we activate heavier and slower checks\n        // to produce better error messages and more complete diagnostics. Extra \"invalid_*\"\n        // rules will be active during parsing.\n        Token *last_token = p->tokens[p->fill - 1];\n        reset_parser_state_for_error_pass(p);\n        _PyPegen_parse(p);\n\n        // Set SyntaxErrors accordingly depending on the parser/tokenizer status at the failure\n        // point.\n        _Pypegen_set_syntax_error(p, last_token);\n       return NULL;\n    }\n\n    if (p->start_rule == Py_single_input && bad_single_statement(p)) {\n        p->tok->done = E_BADSINGLE; // This is not necessary for now, but might be in the future\n        return RAISE_SYNTAX_ERROR(\"multiple statements found while compiling a single statement\");\n    }\n\n    // test_peg_generator defines _Py_TEST_PEGEN to not call PyAST_Validate()\n#if defined(Py_DEBUG) && !defined(_Py_TEST_PEGEN)\n    if (p->start_rule == Py_single_input ||\n        p->start_rule == Py_file_input ||\n        p->start_rule == Py_eval_input)\n    {\n        if (!_PyAST_Validate(res)) {\n            return NULL;\n        }\n    }\n#endif\n    return res;\n}\n\n// 进来以后似乎是一层wrapper，那就再接着往下\n// 函数依然有大段内容在捕获异常，真正起编译作用的是_PyPegen_parse这个函数\n\n\nvoid *\n_PyPegen_parse(Parser *p)\n{\n    // Initialize keywords\n    p->keywords = reserved_keywords;\n    p->n_keyword_lists = n_keyword_lists;\n    p->soft_keywords = soft_keywords;\n\n    // Run parser\n    void *result = NULL;\n    if (p->start_rule == Py_file_input) {\n        result = file_rule(p);\n    } else if (p->start_rule == Py_single_input) {\n        result = interactive_rule(p);\n    } else if (p->start_rule == Py_eval_input) {\n        result = eval_rule(p);\n    } else if (p->start_rule == Py_func_type_input) {\n        result = func_type_rule(p);\n    } else if (p->start_rule == Py_fstring_input) {\n        result = fstring_rule(p);\n    }\n\n    return result;\n}\n\n// _PyPegen_parse这个函数就了不得了，它处在parser.c这个文件的第三万九千行的位置，非常恐怖。\n// 当然，正如在文章开头提到的，这个巨大的parser.c文件也并不是python开发者们一个一个字写出来的，\n// 而是被一个python文件根据语法文件生成出来的。文件在 Tools/peg_generator/pegen 里，有一大坨。\n// 在C里面看了这么久，终于碰到python感动万分，立马进去看一下。\n// 看了以后觉得有点逆天，截取一个方法展示一下\n//    def _set_up_rule_memoization(self, node: Rule, result_type: str) -> None:\n//        self.print(\"{\")\n//        with self.indent():\n//            self.add_level()\n//            self.print(f\"{result_type} _res = NULL;\")\n//            self.print(f\"if (_PyPegen_is_memoized(p, {node.name}_type, &_res)) {{\")\n//            with self.indent():\n//                self.add_return(\"_res\")\n//            self.print(\"}\")\n//            self.print(\"int _mark = p->mark;\")\n//            self.print(\"int _resmark = p->mark;\")\n//            self.print(\"while (1) {\")\n//            with self.indent():\n//                self.call_with_errorcheck_return(\n//                    f\"_PyPegen_update_memo(p, _mark, {node.name}_type, _res)\", \"_res\"\n//                )\n//                self.print(\"p->mark = _mark;\")\n//                self.print(f\"void *_raw = {node.name}_raw(p);\")\n//                self.print(\"if (p->error_indicator) {\")\n//               with self.indent():\n//                   self.add_return(\"NULL\")\n//                self.print(\"}\")\n//                self.print(\"if (_raw == NULL || p->mark <= _resmark)\")\n//                with self.indent():\n//                    self.print(\"break;\")\n//                self.print(f\"_resmark = p->mark;\")\n//                self.print(\"_res = _raw;\")\n//            self.print(\"}\")\n//            self.print(f\"p->mark = _resmark;\")\n//            self.add_return(\"_res\")\n//        self.print(\"}\")\n//        self.print(f\"static {result_type}\")\n//        self.print(f\"{node.name}_raw(Parser *p)\")\n\n// 觉得python的开发者们头还是很铁的，就字符串硬拼啊，dubug时候岂不是。。。\n// 这个文件是python2更新到3的时候创建的，可见当时。。。。。\n// （甚至生成方式和我这个博客的搭建如出一辙）\n\n// 回到parser.c，这个方法里面根据输入的命令的不同，给出了不同的处理\n// 这几个处理的子方法的结构都是差不多的，作为展示，这里依然还是不忘初心，\n// 选择一个interactive_rule吧。\n\n\n// interactive: statement_newline\nstatic mod_ty\ninteractive_rule(Parser *p)\n{\n    if (p->level++ == MAXSTACK) {\n        p->error_indicator = 1;\n        PyErr_NoMemory();\n    }\n    if (p->error_indicator) {\n        p->level--;\n        return NULL;\n    }\n    mod_ty _res = NULL;\n    int _mark = p->mark;\n    { // statement_newline\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> interactive[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"statement_newline\"));\n        asdl_stmt_seq* a;\n        if (\n            (a = statement_newline_rule(p))  // statement_newline\n        )\n        {\n            D(fprintf(stderr, \"%*c+ interactive[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"statement_newline\"));\n            _res = _PyAST_Interactive ( a , p -> arena );\n            if (_res == NULL && PyErr_Occurred()) {\n                p->error_indicator = 1;\n                p->level--;\n                return NULL;\n            }\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s interactive[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"statement_newline\"));\n    }\n    _res = NULL;\n  done:\n    p->level--;\n    return _res;\n}\n\n// 其实，到这一步就发现，它依然还是一个wrapper，核心函数是 _PyAST_Interactive\n// 它长这样：\n// mod_ty\n// _PyAST_Interactive(asdl_stmt_seq * body, PyArena *arena)\n// {\n//     mod_ty p;\n//     p = (mod_ty)_PyArena_Malloc(arena, sizeof(*p));\n//     if (!p)\n//         return NULL;\n//     p->kind = Interactive_kind;\n//     p->v.Interactive.body = body;\n//     return p;\n// }\n// 分配内存，然后实例化一个mod_ty，所以这就需要我们回到mod_ty的实现上去\n// 正如之前说的，mod_ty的实现依赖于_stmt, 而无论是mod_ty 还是 _stmt 都在 pycore-ast.h 里面，\n// 而这个头文件是事先预写好的，并且没有涉及到编译的部分\n// 在这里，源码的追踪变得困难了一些，\n// 其实我们此刻更应该关注的是这个给到_PyAST_Interactive的第一个参数 body。\n// 这个body才是包含了所有结构信息的参数。\n// 所以，回到上面的函数里，body来自参数a，且有这么一行代码，\n// a = statement_newline_rule(p)，\n// 所以应该去看一下statement_newline_rule这个函数。\n\n\n// statement_newline: compound_stmt NEWLINE | simple_stmts | NEWLINE | $\nstatic asdl_stmt_seq*\nstatement_newline_rule(Parser *p)\n{\n    if (p->level++ == MAXSTACK) {\n        p->error_indicator = 1;\n        PyErr_NoMemory();\n    }\n    if (p->error_indicator) {\n        p->level--;\n        return NULL;\n    }\n    asdl_stmt_seq* _res = NULL;\n    int _mark = p->mark;\n    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {\n        p->error_indicator = 1;\n        p->level--;\n        return NULL;\n    }\n    int _start_lineno = p->tokens[_mark]->lineno;\n    UNUSED(_start_lineno); // Only used by EXTRA macro\n    int _start_col_offset = p->tokens[_mark]->col_offset;\n    UNUSED(_start_col_offset); // Only used by EXTRA macro\n    { // compound_stmt NEWLINE\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> statement_newline[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"compound_stmt NEWLINE\"));\n        stmt_ty a;\n        Token * newline_var;\n        if (\n            (a = compound_stmt_rule(p))  // compound_stmt\n            &&\n            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'\n        )\n        {\n            D(fprintf(stderr, \"%*c+ statement_newline[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"compound_stmt NEWLINE\"));\n            _res = ( asdl_stmt_seq* ) _PyPegen_singleton_seq ( p , a );\n            if (_res == NULL && PyErr_Occurred()) {\n                p->error_indicator = 1;\n                p->level--;\n                return NULL;\n            }\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s statement_newline[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"compound_stmt NEWLINE\"));\n    }\n    { // simple_stmts\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> statement_newline[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"simple_stmts\"));\n        asdl_stmt_seq* simple_stmts_var;\n        if (\n            (simple_stmts_var = simple_stmts_rule(p))  // simple_stmts\n        )\n        {\n            D(fprintf(stderr, \"%*c+ statement_newline[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"simple_stmts\"));\n            _res = simple_stmts_var;\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s statement_newline[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"simple_stmts\"));\n    }\n    { // NEWLINE\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> statement_newline[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"NEWLINE\"));\n        Token * newline_var;\n        if (\n            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'\n        )\n        {\n            D(fprintf(stderr, \"%*c+ statement_newline[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"NEWLINE\"));\n            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);\n            if (_token == NULL) {\n                p->level--;\n                return NULL;\n            }\n            int _end_lineno = _token->end_lineno;\n            UNUSED(_end_lineno); // Only used by EXTRA macro\n            int _end_col_offset = _token->end_col_offset;\n            UNUSED(_end_col_offset); // Only used by EXTRA macro\n            _res = ( asdl_stmt_seq* ) _PyPegen_singleton_seq ( p , CHECK ( stmt_ty , _PyAST_Pass ( EXTRA ) ) );\n            if (_res == NULL && PyErr_Occurred()) {\n                p->error_indicator = 1;\n                p->level--;\n                return NULL;\n            }\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s statement_newline[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"NEWLINE\"));\n    }\n    { // $\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> statement_newline[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"$\"));\n        Token * endmarker_var;\n        if (\n            (endmarker_var = _PyPegen_expect_token(p, ENDMARKER))  // token='ENDMARKER'\n        )\n        {\n            D(fprintf(stderr, \"%*c+ statement_newline[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"$\"));\n            _res = _PyPegen_interactive_exit ( p );\n            if (_res == NULL && PyErr_Occurred()) {\n                p->error_indicator = 1;\n                p->level--;\n                return NULL;\n            }\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s statement_newline[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"$\"));\n    }\n    _res = NULL;\n  done:\n    p->level--;\n    return _res;\n}\n\n// 并不短，可以看到函数里应对各种不同的需要换行的情况给出了对应的 asdl_stmt_seq，\n// 当然，作为一个不懂编译原理的人，在这里我就需要小心翼翼地绕开这些 asdl打头的函数\n// 在这里，我们可以关注到两个函数，分别是simple_stmts_rule，和 compound_stmt_rule，\n// 显然，这两个函数就是语法规则了。\n// 选一个simple吧\n\n// simple_stmts: simple_stmt !';' NEWLINE | ';'.simple_stmt+ ';'? NEWLINE\n// simple_stmts_rule函数非常长，并且里面其实是子啊重复调用simple_stmt_rule，\n// 那么我们直接看这个simple_stmt_rule吧。\n\n```\n\n\n\n```c\n// 单个代码块太大会让我的编辑器很卡，所以我在这里换行一下\n\n// simple_stmt:\n//     | assignment\n//     | star_expressions\n//     | &'return' return_stmt\n//     | &('import' | 'from') import_stmt\n//     | &'raise' raise_stmt\n//     | 'pass'\n//     | 'thanks'\n//     | &'del' del_stmt\n//     | &'yield' yield_stmt\n//     | &'assert' assert_stmt\n//     | 'break'\n//     | 'continue'\n//     | &'global' global_stmt\n//     | &'nonlocal' nonlocal_stmt\nstatic stmt_ty\nsimple_stmt_rule(Parser *p)\n{\n    if (p->level++ == MAXSTACK) {\n        p->error_indicator = 1;\n        PyErr_NoMemory();\n    }\n    if (p->error_indicator) {\n        p->level--;\n        return NULL;\n    }\n    stmt_ty _res = NULL;\n    if (_PyPegen_is_memoized(p, simple_stmt_type, &_res)) {\n        p->level--;\n        return _res;\n    }\n    int _mark = p->mark;\n    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {\n        p->error_indicator = 1;\n        p->level--;\n        return NULL;\n    }\n    int _start_lineno = p->tokens[_mark]->lineno;\n    UNUSED(_start_lineno); // Only used by EXTRA macro\n    int _start_col_offset = p->tokens[_mark]->col_offset;\n    UNUSED(_start_col_offset); // Only used by EXTRA macro\n    { // assignment\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> simple_stmt[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"assignment\"));\n        stmt_ty assignment_var;\n        if (\n            (assignment_var = assignment_rule(p))  // assignment\n        )\n        {\n            D(fprintf(stderr, \"%*c+ simple_stmt[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"assignment\"));\n            _res = assignment_var;\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s simple_stmt[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"assignment\"));\n    }\n    { // star_expressions\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> simple_stmt[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"star_expressions\"));\n        expr_ty e;\n        if (\n            (e = star_expressions_rule(p))  // star_expressions\n        )\n        {\n            D(fprintf(stderr, \"%*c+ simple_stmt[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"star_expressions\"));\n            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);\n            if (_token == NULL) {\n                p->level--;\n                return NULL;\n            }\n            int _end_lineno = _token->end_lineno;\n            UNUSED(_end_lineno); // Only used by EXTRA macro\n            int _end_col_offset = _token->end_col_offset;\n            UNUSED(_end_col_offset); // Only used by EXTRA macro\n            _res = _PyAST_Expr ( e , EXTRA );\n            if (_res == NULL && PyErr_Occurred()) {\n                p->error_indicator = 1;\n                p->level--;\n                return NULL;\n            }\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s simple_stmt[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"star_expressions\"));\n    }\n    { // &'return' return_stmt\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> simple_stmt[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"&'return' return_stmt\"));\n        stmt_ty return_stmt_var;\n        if (\n            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 520)  // token='return'\n            &&\n            (return_stmt_var = return_stmt_rule(p))  // return_stmt\n        )\n        {\n            D(fprintf(stderr, \"%*c+ simple_stmt[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"&'return' return_stmt\"));\n            _res = return_stmt_var;\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s simple_stmt[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"&'return' return_stmt\"));\n    }\n    { // &('import' | 'from') import_stmt\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> simple_stmt[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"&('import' | 'from') import_stmt\"));\n        stmt_ty import_stmt_var;\n        if (\n            _PyPegen_lookahead(1, _tmp_6_rule, p)\n            &&\n            (import_stmt_var = import_stmt_rule(p))  // import_stmt\n        )\n        {\n            D(fprintf(stderr, \"%*c+ simple_stmt[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"&('import' | 'from') import_stmt\"));\n            _res = import_stmt_var;\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s simple_stmt[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"&('import' | 'from') import_stmt\"));\n    }\n    { // &'raise' raise_stmt\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> simple_stmt[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"&'raise' raise_stmt\"));\n        stmt_ty raise_stmt_var;\n        if (\n            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 523)  // token='raise'\n            &&\n            (raise_stmt_var = raise_stmt_rule(p))  // raise_stmt\n        )\n        {\n            D(fprintf(stderr, \"%*c+ simple_stmt[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"&'raise' raise_stmt\"));\n            _res = raise_stmt_var;\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s simple_stmt[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"&'raise' raise_stmt\"));\n    }\n    { // 'pass'\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> simple_stmt[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"'pass'\"));\n        Token * _keyword;\n        if (\n            (_keyword = _PyPegen_expect_token(p, 504))  // token='pass'\n        )\n        {\n            D(fprintf(stderr, \"%*c+ simple_stmt[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"'pass'\"));\n            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);\n            if (_token == NULL) {\n                p->level--;\n                return NULL;\n            }\n            int _end_lineno = _token->end_lineno;\n            UNUSED(_end_lineno); // Only used by EXTRA macro\n            int _end_col_offset = _token->end_col_offset;\n            UNUSED(_end_col_offset); // Only used by EXTRA macro\n            _res = _PyAST_Pass ( EXTRA );\n            if (_res == NULL && PyErr_Occurred()) {\n                p->error_indicator = 1;\n                p->level--;\n                return NULL;\n            }\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s simple_stmt[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"'pass'\"));\n    }\n    { // 'thanks'\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> simple_stmt[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"'thanks'\"));\n        Token * _keyword;\n        if (\n            (_keyword = _PyPegen_expect_token(p, 505))  // token='thanks'\n        )\n        {\n            D(fprintf(stderr, \"%*c+ simple_stmt[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"'thanks'\"));\n            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);\n            if (_token == NULL) {\n                p->level--;\n                return NULL;\n            }\n            int _end_lineno = _token->end_lineno;\n            UNUSED(_end_lineno); // Only used by EXTRA macro\n            int _end_col_offset = _token->end_col_offset;\n            UNUSED(_end_col_offset); // Only used by EXTRA macro\n            _res = _PyAST_Thanks ( EXTRA );\n            if (_res == NULL && PyErr_Occurred()) {\n                p->error_indicator = 1;\n                p->level--;\n                return NULL;\n            }\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s simple_stmt[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"'thanks'\"));\n    }\n    { // &'del' del_stmt\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> simple_stmt[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"&'del' del_stmt\"));\n        stmt_ty del_stmt_var;\n        if (\n            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 604)  // token='del'\n            &&\n            (del_stmt_var = del_stmt_rule(p))  // del_stmt\n        )\n        {\n            D(fprintf(stderr, \"%*c+ simple_stmt[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"&'del' del_stmt\"));\n            _res = del_stmt_var;\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s simple_stmt[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"&'del' del_stmt\"));\n    }\n    { // &'yield' yield_stmt\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> simple_stmt[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"&'yield' yield_stmt\"));\n        stmt_ty yield_stmt_var;\n        if (\n            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 574)  // token='yield'\n            &&\n            (yield_stmt_var = yield_stmt_rule(p))  // yield_stmt\n        )\n        {\n            D(fprintf(stderr, \"%*c+ simple_stmt[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"&'yield' yield_stmt\"));\n            _res = yield_stmt_var;\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s simple_stmt[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"&'yield' yield_stmt\"));\n    }\n    { // &'assert' assert_stmt\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> simple_stmt[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"&'assert' assert_stmt\"));\n        stmt_ty assert_stmt_var;\n        if (\n            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 527)  // token='assert'\n            &&\n            (assert_stmt_var = assert_stmt_rule(p))  // assert_stmt\n        )\n        {\n            D(fprintf(stderr, \"%*c+ simple_stmt[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"&'assert' assert_stmt\"));\n            _res = assert_stmt_var;\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s simple_stmt[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"&'assert' assert_stmt\"));\n    }\n    { // 'break'\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> simple_stmt[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"'break'\"));\n        Token * _keyword;\n        if (\n            (_keyword = _PyPegen_expect_token(p, 509))  // token='break'\n        )\n        {\n            D(fprintf(stderr, \"%*c+ simple_stmt[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"'break'\"));\n            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);\n            if (_token == NULL) {\n                p->level--;\n                return NULL;\n            }\n            int _end_lineno = _token->end_lineno;\n            UNUSED(_end_lineno); // Only used by EXTRA macro\n            int _end_col_offset = _token->end_col_offset;\n            UNUSED(_end_col_offset); // Only used by EXTRA macro\n            _res = _PyAST_Break ( EXTRA );\n            if (_res == NULL && PyErr_Occurred()) {\n                p->error_indicator = 1;\n                p->level--;\n                return NULL;\n            }\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s simple_stmt[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"'break'\"));\n    }\n    { // 'continue'\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> simple_stmt[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"'continue'\"));\n        Token * _keyword;\n        if (\n            (_keyword = _PyPegen_expect_token(p, 510))  // token='continue'\n        )\n        {\n            D(fprintf(stderr, \"%*c+ simple_stmt[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"'continue'\"));\n            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);\n            if (_token == NULL) {\n                p->level--;\n                return NULL;\n            }\n            int _end_lineno = _token->end_lineno;\n            UNUSED(_end_lineno); // Only used by EXTRA macro\n            int _end_col_offset = _token->end_col_offset;\n            UNUSED(_end_col_offset); // Only used by EXTRA macro\n            _res = _PyAST_Continue ( EXTRA );\n            if (_res == NULL && PyErr_Occurred()) {\n                p->error_indicator = 1;\n                p->level--;\n                return NULL;\n            }\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s simple_stmt[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"'continue'\"));\n    }\n    { // &'global' global_stmt\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> simple_stmt[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"&'global' global_stmt\"));\n        stmt_ty global_stmt_var;\n        if (\n            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 524)  // token='global'\n            &&\n            (global_stmt_var = global_stmt_rule(p))  // global_stmt\n        )\n        {\n            D(fprintf(stderr, \"%*c+ simple_stmt[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"&'global' global_stmt\"));\n            _res = global_stmt_var;\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s simple_stmt[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"&'global' global_stmt\"));\n    }\n    { // &'nonlocal' nonlocal_stmt\n        if (p->error_indicator) {\n            p->level--;\n            return NULL;\n        }\n        D(fprintf(stderr, \"%*c> simple_stmt[%d-%d]: %s\\n\", p->level, ' ', _mark, p->mark, \"&'nonlocal' nonlocal_stmt\"));\n        stmt_ty nonlocal_stmt_var;\n        if (\n            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 525)  // token='nonlocal'\n            &&\n            (nonlocal_stmt_var = nonlocal_stmt_rule(p))  // nonlocal_stmt\n        )\n        {\n            D(fprintf(stderr, \"%*c+ simple_stmt[%d-%d]: %s succeeded!\\n\", p->level, ' ', _mark, p->mark, \"&'nonlocal' nonlocal_stmt\"));\n            _res = nonlocal_stmt_var;\n            goto done;\n        }\n        p->mark = _mark;\n        D(fprintf(stderr, \"%*c%s simple_stmt[%d-%d]: %s failed!\\n\", p->level, ' ',\n                  p->error_indicator ? \"ERROR!\" : \"-\", _mark, p->mark, \"&'nonlocal' nonlocal_stmt\"));\n    }\n    _res = NULL;\n  done:\n    _PyPegen_insert_memo(p, _mark, simple_stmt_type, _res);\n    p->level--;\n    return _res;\n}\n\n// 可以看到，这里对所有的simple statement都做了实现，那些compound statement就是类似def之类。\n// 选一个我喜欢的关键字pass吧，可以看到这样一段代码\n// (_keyword = _PyPegen_expect_token (p, 504))  // token='pass'\n// _PyPegen_expect_token 这个方法在之前的newline token那里也出现过，\n// 所以，可见所有的token都是由这个方法生成的。\n\n// 进去以后又是非常非常多层的调用，避免篇幅过长就不一一展示了，\n// 最终可以确定到tokenizer.c里面的tok_get\n// 也就是最早最早我在例子里说到的这个长达几百行的函数\n// 给出一小段\n\nstatic int\ntok_get(struct tok_state *tok, const char **p_start, const char **p_end)\n{\n    // printf(\"[start] tokenizer.c tok_get is called\\n\");\n    int c;\n    int blankline, nonascii;\n\n    *p_start = *p_end = NULL;\n  nextline:\n    tok->start = NULL;\n    blankline = 0;\n\n    /* Get indentation level */\n    if (tok->atbol) {\n        int col = 0;\n        int altcol = 0;\n        tok->atbol = 0;\n        int cont_line_col = 0;\n        for (;;) {\n            c = tok_nextc(tok);\n            if (c == ' ') {\n                col++, altcol++;\n            }\n            else if (c == '\\t') {\n                col = (col / tok->tabsize + 1) * tok->tabsize;\n                altcol = (altcol / ALTTABSIZE + 1) * ALTTABSIZE;\n            }\n            else if (c == '\\014')  {/* Control-L (formfeed) */\n                col = altcol = 0; /* For Emacs users */\n            }\n            else if (c == '\\\\') {\n                // Indentation cannot be split over multiple physical lines\n                // using backslashes. This means that if we found a backslash\n                // preceded by whitespace, **the first one we find** determines\n                // the level of indentation of whatever comes next.\n                cont_line_col = cont_line_col ? cont_line_col : col;\n                if ((c = tok_continuation_line(tok)) == -1) {\n                    return ERRORTOKEN;\n                }\n            }\n            else {\n                break;\n            }\n        }\n        tok_backup(tok, c);\n        if (c == '#' || c == '\\n') {\n        。。。。。。}\n    }\n}\n            \n// 可以看到，这个方法所处理的第一个内容就是python的缩进，\n// 对的，在python中，缩进是一个单独的token\n// 可以看到下面紧接着处理的是注释和换行符\n// 至于这个方法是如何获得我们写的文本，我们进入tok_nextc看一下\n\n/* Get next char, updating state; error code goes into tok->done */\n\nstatic int\ntok_nextc(struct tok_state *tok)\n{\n    int rc;\n    for (;;) {\n        if (tok->cur != tok->inp) {\n            return Py_CHARMASK(*tok->cur++); /* Fast path */\n        }\n        if (tok->done != E_OK) {\n           return EOF;\n        }\n        if (tok->fp == NULL) {\n            rc = tok_underflow_string(tok);\n        }\n        else if (tok->prompt != NULL) {\n            rc = tok_underflow_interactive(tok);\n        }\n        else {\n            rc = tok_underflow_file(tok);\n        }\n#if defined(Py_DEBUG)\n        if (tok->debug) {\n            fprintf(stderr, \"line[%d] = \", tok->lineno);\n            print_escape(stderr, tok->cur, tok->inp - tok->cur);\n            fprintf(stderr, \"  tok->done = %d\\n\", tok->done);\n        }\n#endif\n        if (!rc) {\n            tok->cur = tok->inp;\n            return EOF;\n        }\n        tok->line_start = tok->cur;\n    }\n    Py_UNREACHABLE();\n}\n\n// tok_state 主要是存储文件阅读的情况，比如现在tokenizer正读到第几个字就是tok->cur\n// 这里就很清楚的看到，用Py_CHARMASK这个宏转换了一下tok->cur的下一个字符\n// /* Argument must be a char or an int in [-128, 127] or [0, 255]. */\n// #define Py_CHARMASK(c) ((unsigned char)((c) & 0xff))\n// 宏的定义在这里\n\n// 这么看来，我写的所有python文本都在这个存在tok_state里面，\n// 的确，如果去看tok_state的实现，可以看到其第一个参数就是buf，\n// 存储的就是字符串形式的文本信息。\n// 而这个文本信息自从被打开以后就一直存在FILE fp里面，作为参数传递\n// 直到 _PyPegen_run_parser_from_file_pointer 函数，有这么一行\n// struct tok_state *tok = _PyTokenizer_FromFile(fp, enc, ps1, ps2);\n// fp的信息被写进了tok_state,而后，\n// Parser *p = _PyPegen_Parser_New(tok, start_rule, parser_flags, PY_MINOR_VERSION,\n//                                    errcode, arena);\n// tok 这个变量又被作为参数用于生成 parser 了。\n// 再往后这个parser就一直作为变量传递到底层，\n// 一直到tokenizer.c这个文件之后，p->tok 这个参数又重新被拿出来使用。\n// 也正因为如此，在最底层的 tok_nextc 才可以持续读出字符\n\n// 终于，我们已经完成了全部全部的步骤，知道当我们在python里敲下回车的时候都发生了什么\n// 虽然很不完全，呵呵\n```\n\n至此，在小心翼翼地绕开了AST部分之后，代码的tracing就已经结束了。\n\n回头看来，每个函数的结构都不复杂，但是调用层数多达几十上百层以后确实让人眼花缭乱。\n\n一个较大项目的源码并不是说啃就能啃下来的，特别是在翻遍了国内外的互联网也没有找到详细的资料的时候。所以，借此机会，我决定记录一下我的探索，虽然不一定能帮到后来者。\n\n最终，弄明白一切之后，我也就仅仅给尚未新生的pPy添加了一个关键字，thanks，语法和pass无异。然后，我写了我的第一个，也许也是全世界唯一一份pPy程序，只有一个词，thanks。它会一路从main调用到tok_nextc，然后再返回，但是什么都达成不了，就和没做一样，就和我做的这些一样。不过，至少编译通过的时候我还是挺开心的，我知道后续若想让pPy可以实现a++的语法也不难了。\n\n\n\n\n\n在长达或是短至十个小时的挣扎后，我们可怜的pPy算是寿终正寝或是胎死腹中了。我自问，潜下心来，一点点在CPython里把这个小项目做出来并不是一件不可能的事，但是，我哪里来的这些时间呢？这个没有生产力的小项目做出来又有什么用呢？我花费的这些时间和心血最终能有回报吗？\n\n临时兴起很容易，做下去很难。\n\npPy死了，和我曾打过的许多小算盘埋在一起，没有坟墓。"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.2.269","theme":{"light":["lux","../../light.scss"],"dark":["cyborg","../../dark.scss"]},"title-block-banner":true,"comments":{"utterances":{"repo":"midstreeeam/blogComments"}},"title":"在 pPy 同志追悼会上的祷词","author":"Midstream","date":"2022-09-05","categories":["日常","学习笔记"],"description":"临时兴起很容易，做下去很难。"},"extensions":{"book":{"multiFile":true}}}}}